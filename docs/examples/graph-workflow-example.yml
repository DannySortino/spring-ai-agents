# Graph Workflow Example Configuration
# This example demonstrates the unified GRAPH workflow type that supports:
# - Arbitrary dependencies between nodes
# - Conditional logic (if/then/else branching)
# - Orchestrator patterns (manager-worker-synthesizer)
# - Routing patterns (content-based routing)
# - Complex combinations of all patterns
#
# IMPORTANT: All agents MUST include both 'input_node' and 'output_node':
# - input_node: Entry point where agent receives user requests via agentService.invoke()
# - output_node: Exit point that returns the final result to the user
# These nodes are mandatory for proper workflow validation and execution.

agents:
  list:
      - name: "data-analysis-agent"
        systemPrompt: "You are a data analysis expert. Process requests step by step with proper dependencies."
        workflow:
          type: graph
          chain:
            # REQUIRED: input_node - Entry point for user requests
            - nodeId: "input_node"
              prompt: "Receive and validate user data analysis request: {input}"
              
            # Node A: Initial data extraction (depends on input_node)
            - nodeId: "extract_data"
              dependsOn: ["input_node"]
              prompt: "Extract key data points from the input: {input_node}"
              
            # Node B: Statistical analysis (depends on A)
            - nodeId: "statistical_analysis"
              dependsOn: ["extract_data"]
              prompt: "Perform statistical analysis on the extracted data: {extract_data}"
              
            # Node C: Trend analysis (depends on A)
            - nodeId: "trend_analysis"
              dependsOn: ["extract_data"]
              prompt: "Identify trends in the data: {extract_data}"
              
            # Node D: Final report (depends on both B and C, demonstrating A->B, A->C, B->D, C->D pattern)
            - nodeId: "generate_report"
              dependsOn: ["statistical_analysis", "trend_analysis"]
              prompt: "Generate a comprehensive report combining statistical analysis: {statistical_analysis} and trend analysis: {trend_analysis}"
              
            # REQUIRED: output_node - Final result returned to user
            - nodeId: "output_node"
              dependsOn: ["generate_report"]
              prompt: "Present final analysis report: {generate_report}"

      - name: "research-workflow-agent"
        systemPrompt: "You are a research assistant that conducts thorough analysis."
        workflow:
          type: graph
          chain:
            # REQUIRED: input_node - Entry point for user requests
            - nodeId: "input_node"
              prompt: "Receive and categorize research request: {input}"
              
            # Complex dependency pattern: A->B, B->C, A->C (as specified in the issue)
            - nodeId: "initial_research"
              dependsOn: ["input_node"]
              prompt: "Conduct initial research on: {input_node}"
              
            - nodeId: "deep_dive"
              dependsOn: ["initial_research"]
              prompt: "Perform deep dive analysis based on initial findings: {initial_research}"
              
            - nodeId: "synthesis"
              dependsOn: ["initial_research", "deep_dive"]
              prompt: "Synthesize findings from initial research: {initial_research} and deep dive: {deep_dive}"
              
            # REQUIRED: output_node - Final result returned to user
            - nodeId: "output_node"
              dependsOn: ["synthesis"]
              prompt: "Present comprehensive research findings: {synthesis}"

      - name: "tool-integration-agent"
        systemPrompt: "You are an agent that integrates multiple tools in a workflow."
        workflow:
          type: graph
          chain:
            # REQUIRED: input_node - Entry point for user requests
            - nodeId: "input_node"
              prompt: "Receive and prepare search query: {input}"
              
            # Node with tool call (depends on input_node)
            - nodeId: "search_web"
              dependsOn: ["input_node"]
              tool: "web_search"
              
            # Node depending on tool result
            - nodeId: "analyze_results"
              dependsOn: ["search_web"]
              prompt: "Analyze the search results: {search_web}"
              
            # Parallel processing of analysis
            - nodeId: "extract_facts"
              dependsOn: ["analyze_results"]
              prompt: "Extract key facts from: {analyze_results}"
              
            - nodeId: "identify_sources"
              dependsOn: ["analyze_results"]
              prompt: "Identify reliable sources from: {analyze_results}"
              
            # Final synthesis
            - nodeId: "create_summary"
              dependsOn: ["extract_facts", "identify_sources"]
              prompt: "Create summary with facts: {extract_facts} and sources: {identify_sources}"
              
            # REQUIRED: output_node - Final result returned to user
            - nodeId: "output_node"
              dependsOn: ["create_summary"]
              prompt: "Present final research summary: {create_summary}"

      - name: "parallel-processing-agent"
        systemPrompt: "You demonstrate parallel execution of independent nodes."
        workflow:
          type: graph
          chain:
            # REQUIRED: input_node - Entry point for user requests
            - nodeId: "input_node"
              prompt: "Receive user request: {input}"
              
            # Root node
            - nodeId: "input_processing"
              dependsOn: ["input_node"]
              prompt: "Process and categorize input: {input_node}"
              
            # Three independent branches that can execute in parallel
            - nodeId: "branch_a"
              dependsOn: ["input_processing"]
              prompt: "Process branch A: {input_processing}"
              
            - nodeId: "branch_b"
              dependsOn: ["input_processing"]
              prompt: "Process branch B: {input_processing}"
              
            - nodeId: "branch_c"
              dependsOn: ["input_processing"]
              prompt: "Process branch C: {input_processing}"
              
            # Convergence node
            - nodeId: "merge_results"
              dependsOn: ["branch_a", "branch_b", "branch_c"]
              prompt: "Merge results from A: {branch_a}, B: {branch_b}, C: {branch_c}"
              
            # REQUIRED: output_node - Final result returned to user
            - nodeId: "output_node"
              dependsOn: ["merge_results"]
              prompt: "Present final merged results: {merge_results}"

      # Conditional Logic Agent - demonstrates all condition types
      - name: "conditional-logic-agent"
        systemPrompt: "You are an intelligent assistant with advanced conditional logic capabilities."
        workflow:
          type: graph
          chain:
            # REQUIRED: input_node - Entry point for user requests
            - nodeId: "input_node"
              prompt: "Receive and prepare request for conditional processing: {input}"
            
            # EQUALS condition example
            - nodeId: "priority_check"
              dependsOn: ["input_node"]
              conditional:
                condition:
                  type: EQUALS
                  field: "input_node"
                  value: "high priority"
                  ignoreCase: true
                thenStep:
                  prompt: "HIGH PRIORITY: Immediate attention required for: {input_node}"
                elseStep:
                  prompt: "Standard processing for: {input_node}"
            
            # CONTAINS condition with nested logic
            - nodeId: "content_analysis"
              dependsOn: ["priority_check"]
              conditional:
                condition:
                  type: CONTAINS
                  field: "input_node"
                  value: "urgent"
                  ignoreCase: true
                thenStep:
                  conditional:
                    condition:
                      type: REGEX
                      field: "input_node"
                      value: ".*emergency.*|.*critical.*|.*urgent.*"
                    thenStep:
                      prompt: "EMERGENCY PROTOCOL: {input_node} - Escalating immediately"
                      tool: "emergencyTool"
                    elseStep:
                      prompt: "Urgent but manageable: {input_node}"
                elseStep:
                  prompt: "Regular processing: {input_node}"
            
            # EXISTS and EMPTY condition examples
            - nodeId: "validation_check"
              dependsOn: ["content_analysis"]
              conditional:
                condition:
                  type: EXISTS
                  field: "context.userId"
                thenStep:
                  prompt: "Authenticated user request: {input_node}"
                elseStep:
                  prompt: "Anonymous request: {input_node} - Limited functionality available"
            
            # REQUIRED: output_node - Final result returned to user
            - nodeId: "output_node"
              dependsOn: ["validation_check"]
              prompt: "Present final conditional processing result: {validation_check}"

      # Orchestrator Pattern Agent - manager-worker-synthesizer using GraphWorkflow
      - name: "orchestrator-agent"
        systemPrompt: "You are a project manager coordinating specialized teams."
        workflow:
          type: graph
          chain:
            # REQUIRED: input_node - Entry point for user requests
            - nodeId: "input_node"
              prompt: "Receive project request: {input}"
            
            # Manager node - analyzes and makes decisions
            - nodeId: "manager"
              dependsOn: ["input_node"]
              prompt: "As project manager, analyze this request and determine team assignments: {input_node}"
            
            # Worker nodes - execute in parallel, all depend on manager
            - nodeId: "technical_specialist"
              dependsOn: ["manager"]
              prompt: "Technical Specialist - Manager decision: {manager} - Handle technical aspects: {input_node}"
            
            - nodeId: "business_analyst"
              dependsOn: ["manager"]
              prompt: "Business Analyst - Manager decision: {manager} - Analyze business requirements: {input_node}"
            
            - nodeId: "quality_assurance"
              dependsOn: ["manager"]
              prompt: "QA Specialist - Manager decision: {manager} - Review quality aspects: {input_node}"
            
            # Synthesizer node - combines all results
            - nodeId: "project_synthesizer"
              dependsOn: ["manager", "technical_specialist", "business_analyst", "quality_assurance"]
              prompt: |
                Project Summary:
                Manager Decision: {manager}
                Technical Analysis: {technical_specialist}
                Business Analysis: {business_analyst}
                Quality Review: {quality_assurance}
                
                Provide comprehensive project recommendations.
            
            # REQUIRED: output_node - Final result returned to user
            - nodeId: "output_node"
              dependsOn: ["project_synthesizer"]
              prompt: "Present final project recommendations: {project_synthesizer}"

      # Advanced Routing Agent - content-based routing with conditional logic
      - name: "advanced-routing-agent"
        systemPrompt: "You are a smart routing system that directs requests to appropriate handlers."
        workflow:
          type: graph
          chain:
            # REQUIRED: input_node - Entry point for user requests
            - nodeId: "input_node"
              prompt: "Receive request for intelligent routing: {input}"
            
            - nodeId: "intelligent_router"
              dependsOn: ["input_node"]
              conditional:
                condition:
                  type: REGEX
                  field: "input_node"
                  value: ".*technical.*|.*bug.*|.*error.*|.*system.*"
                thenStep:
                  prompt: "TECHNICAL ROUTE: Routing to technical support: {input_node}"
                  tool: "technicalSupportTool"
                elseStep:
                  conditional:
                    condition:
                      type: CONTAINS
                      field: "input_node"
                      value: "billing"
                      ignoreCase: true
                    thenStep:
                      conditional:
                        condition:
                          type: CONTAINS
                          field: "input_node"
                          value: "dispute"
                          ignoreCase: true
                        thenStep:
                          prompt: "BILLING DISPUTE ROUTE: Handling billing dispute: {input_node}"
                          tool: "billingDisputeTool"
                        elseStep:
                          prompt: "BILLING ROUTE: Handling billing inquiry: {input_node}"
                          tool: "billingTool"
                    elseStep:
                      conditional:
                        condition:
                          type: EMPTY
                          field: "context.userType"
                        thenStep:
                          prompt: "GUEST ROUTE: Limited assistance for guest user: {input_node}"
                        elseStep:
                          prompt: "GENERAL ROUTE: Full assistance for registered user: {input_node}"
            
            # Follow-up processing based on routing decision
            - nodeId: "post_routing_analysis"
              dependsOn: ["intelligent_router"]
              prompt: "Analyze routing decision and provide additional context: {intelligent_router}"
            
            # REQUIRED: output_node - Final result returned to user
            - nodeId: "output_node"
              dependsOn: ["post_routing_analysis"]
              prompt: "Present final routing result: {post_routing_analysis}"

      # Complex Combined Pattern Agent - shows orchestrator + conditional + routing
      - name: "complex-unified-agent"
        systemPrompt: "You are an advanced AI system combining multiple workflow patterns."
        workflow:
          type: graph
          chain:
            # REQUIRED: input_node - Entry point for user requests
            - nodeId: "input_node"
              prompt: "Receive request for complex unified processing: {input}"
            
            # Initial routing decision
            - nodeId: "request_classifier"
              dependsOn: ["input_node"]
              conditional:
                condition:
                  type: CONTAINS
                  field: "input_node"
                  value: "complex"
                  ignoreCase: true
                thenStep:
                  prompt: "Complex request detected - initiating orchestrator pattern: {input_node}"
                elseStep:
                  prompt: "Simple request - direct processing: {input_node}"
            
            # Conditional orchestrator activation
            - nodeId: "orchestrator_manager"
              dependsOn: ["request_classifier"]
              conditional:
                condition:
                  type: CONTAINS
                  field: "request_classifier"
                  value: "orchestrator"
                thenStep:
                  prompt: "Manager: Coordinating complex request: {input_node}"
                elseStep:
                  prompt: "Direct handler: Processing simple request: {input_node}"
            
            # Parallel workers (only activated for complex requests)
            - nodeId: "specialist_a"
              dependsOn: ["orchestrator_manager"]
              conditional:
                condition:
                  type: CONTAINS
                  field: "orchestrator_manager"
                  value: "Coordinating"
                thenStep:
                  prompt: "Specialist A: {orchestrator_manager} - Handling aspect A of: {input_node}"
                elseStep:
                  prompt: "Skipping specialist A for simple request"
            
            - nodeId: "specialist_b"
              dependsOn: ["orchestrator_manager"]
              conditional:
                condition:
                  type: CONTAINS
                  field: "orchestrator_manager"
                  value: "Coordinating"
                thenStep:
                  prompt: "Specialist B: {orchestrator_manager} - Handling aspect B of: {input_node}"
                elseStep:
                  prompt: "Skipping specialist B for simple request"
            
            # Final synthesis
            - nodeId: "final_synthesizer"
              dependsOn: ["specialist_a", "specialist_b"]
              prompt: |
                Final Response:
                Classification: {request_classifier}
                Management: {orchestrator_manager}
                Specialist A: {specialist_a}
                Specialist B: {specialist_b}
                
                Provide comprehensive final response.
            
            # REQUIRED: output_node - Final result returned to user
            - nodeId: "output_node"
              dependsOn: ["final_synthesizer"]
              prompt: "Present final unified processing result: {final_synthesizer}"

# MCP Server Configuration (if using tools)
mcp:
  servers:
    web_search:
      command: "npx"
      args: ["-y", "@modelcontextprotocol/server-web-search"]
      env:
        BRAVE_API_KEY: "${BRAVE_API_KEY}"